---
title: V8相关
date: '2023-3-9'
tags: ['V8 Engine', 'JavaScript']
draft: false
summary: 'V8引擎笔记'
authors: ['default']
---

# V8 引擎:其实就是 JavaScript 的虚拟机

`虚拟机`:通过模拟实际计算机的各种功能来实现代码的执行,如模拟实际计算机的 CPU、堆栈、寄存器等,虚拟机还具有它自己的一套指令系统

- V8 之前所有的 JavaScript 虚拟机都是采用`解释执行`的方式,所以那时解析 JavaScript 速度过慢
- V8 则率先引入了`即时编译(JIT)的双轮驱动`的设计:`混合编译执行`和`解释执行`这两种手段
- V8 也是早于其他虚拟机引入了`惰性编译`、`内联缓存`、`隐藏类`等机制,进一步优化了 JavaScript 代码的编译执行效率

![](/blog/JS设计思想.png)

# 什么是 V8(宏观)

V8 是一个由 Google 开发的开源 `JavaScript 引擎`,目前用在 Chrome 浏览器和 Node.js 中,其核心功能是执行易于人类理解的 JavaScript 代码

## 为什么需要先编译后执行 JavaScript 这一高级语言

为了能够完成复杂的任务,工程师们为 CPU 提供了一大堆指令,来实现各种功能,我们就把这一大堆指令称为`指令集(Instructions)`,也就是`机器语言`

CPU 只能识别二进制的指令,但是对程序员来说,二进制代码难以阅读和记忆,于是我们又将二进制指令集转换为人类可以识别和记忆的符号,这就是`汇编指令集`,如下:

```
1000100111011000 机器指令
mov ax,bx 汇编指令
```

- 通常有两种方式可以让处理器直接执行高级语言的代码:

  - 第一种是`解释执行`,需要先将输入的源代码通过解析器编译成中间代码,之后直接使用解释器解释执行中间代码,然后直接输出结果.具体流程如下图所示:

    ![](/blog/解释执行.png)

  - 第二种是`编译执行`.采用这种方式时,也需要先将源代码转换为中间代码,然后我们的编译器再将中间代码编译成机器代码.通常编译成的机器代码是以二进制文件形式存储的,需要执行这段程序的时候直接执行二进制文件就可以了.还可以使用虚拟机将编译后的机器代码保存在内存中,然后直接执行内存中的二进制代码.如下:

    ![](/blog/编译执行.png)

JavaScript 流行的虚拟机:苹果公司在 Safari 中就是用 JavaScriptCore 虚拟机,Firefox 使用了 TraceMonkey 虚拟机,而 Chrome 则使用了 V8 虚拟机

`V8 编译`完整过程如下:

![](/blog/V8流水线.png)

上图可以看到,在 V8 启动执行 JavaScript 之前,它还需要准备执行 JavaScript 时所需要的一些基础环境,这些基础环境包括了` 堆空间` `栈空间` `全局执行上下文` `全局作用域` `消息循环系统` `内置函数 `等,这些内容都是在执行 JavaScript 过程中需要使用到的

基础环境准备好之后,接下来就可以向 V8 提交要执行的 JavaScript 代码了。
首先 V8 会接收到要执行的 JavaScript 源代码,不过这对 V8 来说只是一堆字符串,V8 并不能直接理解这段字符串的含义,它需要结构化这段字符串。结构化,是指信息经过分析后可分解成多个互相关联的组成部分,各组成部分间有明确的层次结构,方便使用和维护,并有一定的操作规范。
V8 源代码的结构化之后,就生成了抽象语法树 (AST),我们称为 AST,AST 是便于 V8 理解的结构.同时,V8 还会生成相关的作用域,作用域中存放相关变量

- 总结为:
  1. 初始化基础环境
  2. 解析源码生成 AST 和作用域
  3. 依据 AST 和作用域生成字节码
  4. 解释执行字节码
  5. 监听热点代码
  6. 优化热点代码为二进制的机器代码 7.反优化生成的二进制机器代码

# JavaScript 是基于对象实现的语言(但是并不是一门面向对象语言,因为 JavaScript 实现多态很复杂)

# 对于使用 delete 删除对象属性的看法

<div className="text-2xl text-cyan-300">为什么不建议使用 delete 删除对象属性</div>

首先 MDN 文档中是这样描述 delete 的: delete 操作符用于删除对象的某个属性；如果没有指向这个属性的引用,那它最终会被释放。

举个 🌰:

```js
function Creator() {
  this.prop = 'prop'
}
creator.prototype.prop = 'prop'
let creator = new Creator()
delete creator.prop
console.log(creator.prop) // 仍然会通过原型链取到 prop 值,从而打印出来
```

同时因为 V8 引擎中 elemens(key 为数字) 和 properties(key 为字符串) 的不同存储方式,properties 中默认十个(内属性)仍然在对象内存下存放,然后数量少由线性排列存放在 properties 属性下,过多占用则以字典形式存储

快属性:elements 和内属性
慢属性:properties

通过开头引用 MDN 描述,可以预想,若是对于在线性表存放的对象属性,使用 delete 操作后,不会释放该内存,从而会破坏线性表结构.影响查询性能

<div className="text-2xl text-cyan-300">建议使用赋值为 undefined 删除对象属性</div>

不仅可以做到同使用 delete 操作符下的同样结果,还能阻止通过原型链查找
