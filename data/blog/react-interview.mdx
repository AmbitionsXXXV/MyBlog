---
title: React Interview
date: '2023-3-3'
tags: ['React', 'Interview']
draft: false
summary: 'React深入了解(面试向)'
authors: ['default']
---

## 什么是 Fiber? Why Fiber

- Why Fiber:

  - 因为`JavaScript`引擎和页面渲染引擎两个线程是互斥的,当其中一个线程执行时,另一个线程只能挂起等待.`React 15` 版本`Stack Reconciler`渲染界面时,从开始到渲染完成整个过程是一气呵成的,无法中断
    如果组件较大,那么 js 线程会一直执行,然后等到整棵 `VDOM` 树计算完成后,才会交给渲染的线程.这就会导致一些用户交互、动画等任务无法立即得到处理,导致卡顿的情况
  - `Fiber`便是 React 团队对该问题的解决方案的产物,于`React 16`正式发布.`Fiber`是对核心算法的重写,其中主要做了以下操作:
    - 为每个增加了优先级,优先级高的任务可以中断低优先级的任务。然后再重新,注意是重新执行优先级低的任务
    - 增加了异步任务,调用 `requestIdleCallback` api,浏览器空闲的时候执行
    - `dom diff 树`变成了链表,一个 dom 对应两个 `fiber`(一个链表),对应两个队列,这都是为找到被中断的任务,重新执行

- 总结:
  - 从架构角度来看,`Fiber` 是对 React 核心算法(即调和过程)的重写
  - 从编码角度来看,`Fiber` 是 React 内部所定义的一种数据结构,它是 `Fiber 树`结构的节点单位,也就是 `React 16` 新架构下的虚拟 DOM
    - 一个 `fiber` 就是一个 `JavaScript对象`,包含了元素的信息、该元素的更新操作队列、类型
    - 每个 Fiber 节点有个对应的 React element,多个 Fiber 节点根据如下三个属性构建一颗树:
    ```js
    // 指向父级Fiber节点
    this.return = null
    // 指向子Fiber节点
    this.child = null
    // 指向右边第一个兄弟Fiber节点
    this.sibling = null
    ```
  - `Fiber`的工作愿景:
    - pause work and come back to it later(暂停工作,并且能之后回到暂停的地方)
    - assign priority to different types of work(安排不同类型工作的优先级)
    - reuse previously completed work(之前已经处理完的工作单元,可以得到重用)
    - abort work if it's no longer needed(如果后续的工作不再需要做,工作可以直接被终止)

## FiberRoot 和 rootFiber 的区别

两者关系:

![](/blog/fiberRoot和rootFiber.png)

在应用中 `ReactDOM.render` 可以被多次调用, 它们可以拥有不同的`rootFiber(FiberNode)`, 但是整个应用的根节点只能是一个, 那就是`fiberRoot(fiberRootNode)`

#### FiberRoot(fiberRootNode)

它是整个应用的根节点, 绑定在`container._reactRootContainer`, 也就是绑定在真实 DOM 节点的`_reactRootContainer`属性上, 就算是重复调用`ReactDOM.render`, `FiberRoot(fiberRootNode)`还是不变的, 内部做了判断

#### rootFiber(fiberNode)

`rootFiber`是`<App/>`所在组件树的根节点,`rootFiber`在每次重新渲染的时候会重新构建。
本身就是一个普通的 fiberNode, 上面通过`createHostRootFiber(tag)`创建, 其实最终还是通过`createFiber`函数创建的.
